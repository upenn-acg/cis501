## Lab 4: Pipelined Processor

Your pipelined LC4 processor must be fully-bypassed, and must predict all branches as not taken (including JMP, TRAP, and RTI). It should stall only in the load-to-use case. To be clear, when you encounter a load-to-use, you insert the NOP bubble as if it was between the load and the use. For example, if you have a `load` followed by an `add`, it would look in the pipeline like you have `load` followed by `NOP` followed by `add` - `load` in W, `NOP` in M, `add` in X.

At startup, the pipeline should be filled with NOPs and treated as instructions that were flushed due to a branch mispredict (i.e. `test_stall` should be set to 2 - see below). Implement this by setting the default values of your pipeline registers appropriate. See the declaration of `pc_reg` in the single-cycle data path for an example.

To set the initial value of a register, modify the second parameter value. Note that reading from a register takes place before writing to it.

The initial value of your `pc_reg` in the Fetch stage should be `16'h8200`.

The only time you should stall unnecessarily is on a `BRnzp` instruction that depends on a prior load. (Technically, `BRnzp` doesn't depend on the condition codes of the previous instruction since it will always be taken, but we'll assume any good compiler/programmer will a `JMP` insn instead to you don't have to handle BRnzp specially).

You should bypass at the beginning of a stage to the beginning of another stage, so that values are bypassed right after they come out of your pipeline registers. Some groups have in the past implemented this lab so that they bypass from the end of a stage to the end of another stage, but this is more difficult.

You **should not stall** in situations where you store a piece of data you just loaded, e.g.:
```
LDR R1, R2, 5     // load R1
STR R1, R3, 6     // store R1 -> [R3 + 6]
```
instead, you should forward the load instruction's output from the writeback stage to the store's memory stage. This uses the WM bypass.

Assume that instruction memory is never over-written.

### Test Signals

This lab uses the `test_data/*.ctrace` files, which contain a cycle-by-cycle trace of all of the test signals generated by our solution. Your pipeline should match these signals exactly.

Whereas the test wires should be set in the Writeback stage, `o_cur_pc` is the pc in Fetch stage (the output of the PC register in Fetch stage), and the `o_dmem_*` wires are set in Memory stage.

`test_stall` is a two-bit testbench signal that you should set as follows:
+ 0: no stall
+ 1: reserved for the superscalar design; for this lab, never set test_stall to 1
+ 2: flushed due to misprediction or because the first real instruction hasn't made it through to the writeback stage yet
+ 3: stalled due to load-to-use penalty
All other ports on the processor module are identical to your single-cycle implementation.

`switch_data` and `led_data`: You may safely ignore these ports. They provide your processor with the states of the Zedboard's switches and allow you to control its LEDs. If you want to use these for your own testing, or just for fun, use the example debugging code from the `lc4_single.v` skeleton as a starting point. (Use of the display and LEDs is strictly optional. There are no points or extra credit associated with it.)

### General Advice

Writing sub-modules: It is tempting to make one module for each pipeline stage and/or for each pipeline register. We recommend against this. A single, giant module is easier to debug because you can view all the signals in one big list in the debugger. Combinational loops are also somewhat liklier this way, which will cause the simulator to hang (`make synth` will catch such loops, however).

Port/Wire Shadowing: Make sure you do not declare any wires with the same name as a port (equivalent to variable shadowing). By default, the synthesizer will issue a warning about this and ignore the second declaration. One good rule of thumb is to avoid any wire declarations that start with `o_`, `i_`, or `test_`. Reserve these prefixes for the ports.

## Debugging

Debugging this assignment will be *much*, **much** harder than debugging the single-cycle datapath. **Get started early and plan on many debug sessions involving all team members!** Having a clear schematic that matches up with your code will make life much easier. Also consider the following debugging tips:

+ In the output pane, right-click your PC wires and any others whose values your are monitoring as numbers, and set their radix to hexadecimal.
+ The skeleton `lc4_pipeline.v` contains an `always (posedge gwe)` block at the end. Leave this at the end of the module and add `$display` statements to print out values you are interested in. These will get printed at the end of each cycle, when all wire values are valid. Please **comment out these $display statements** before submitting code to the autograder, as the autograder's email will truncate output (which may contain relevant errors/warnings).
+ You can set a breakpoint on a `$display` call in your `always` block to get Vivado to break at the end of each cycle. This is much more effective than setting breakpoints elsewhere in your code. An empty `$display();` statement at the very end of the block is especially useful for setting a breakpoint. You can also single-step forward 40ns to move forward one cycle.
+ Start with the `test_alu` test case, and do not move on until it is completely working. Move through the test cases one by one.
+ The testbench will stop as soon as it encounters an error and print out both the line number (n) and instruction.
++ Consider creating a pipeline diagram (as we've used in lecture) of the corresponding ASM file for the first `n` instructions. Mark all bypasses, stalls, squashes, and register contents on your diagram. (Spreadsheets are good for this--use one row for each instruction, one column for each cycle, and fill in the pipeline stages like the examples on the lecture slide.)
++ Next, step through your code by setting a breakpoint in the `always` block, and compare your signals to the expected values in every pipeline stage. This is very helpful to identify undeclared wires (which default to 1 bit wide), incorrect bypass logic, etc.
+ You can print out an instruction's disassembly inside the `@always` block via the `pinstr()` subroutine. See the file `include/lc4_prettyprint_errors.v` for more details.

## Demo

TBD
